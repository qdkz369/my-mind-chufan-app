# 登录系统代码整理

## 问题描述
用户报告登录后出现循环登录问题：点击登录后一直处于"检查登录状态"的加载画面，然后回到登录界面，账号密码被清空，无法停止登录循环。

## 相关文件清单

### 1. 登录页面
- **文件路径**: `app/login/page.tsx`
- **功能**: 管理员登录界面，包含登录表单、会话检查、角色验证

### 2. 路由保护中间件
- **文件路径**: `proxy.ts` (Next.js 16 使用 proxy 替代 middleware)
- **功能**: 保护 `/dashboard` 和 `/admin` 路由，检查用户登录状态和角色

### 3. Supabase 客户端配置
- **文件路径**: `lib/supabase.ts`
- **功能**: Supabase 客户端初始化

### 4. 创建公司 API（需要登录验证）
- **文件路径**: `app/api/admin/create-company/route.ts`
- **功能**: 创建供应商公司，需要管理员权限

### 5. 数据库表结构
- **user_roles 表**: 存储用户角色信息
- **RLS 策略**: 控制用户对 user_roles 表的访问权限

---

## 1. 登录页面代码

**文件**: `app/login/page.tsx`

```typescript
"use client"

import { useState, useEffect, useRef } from "react"
import { supabase } from "@/lib/supabase"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Button } from "@/components/ui/button"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { Loader2, Shield, AlertCircle } from "lucide-react"

export default function LoginPage() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [isChecking, setIsChecking] = useState(true)
  const hasCheckedRef = useRef(false) // 使用 ref 防止重复检查
  const isRedirectingRef = useRef(false) // 防止重复跳转

  // 检查是否已登录（只在页面首次加载时检查一次）
  useEffect(() => {
    // 防止重复检查
    if (hasCheckedRef.current || isRedirectingRef.current) {
      setIsChecking(false)
      return
    }

    const checkSession = async () => {
      hasCheckedRef.current = true

      try {
        const { data: { session } } = await supabase.auth.getSession()
        
        if (session) {
          // 已登录，检查是否是管理员
          const { data: { user } } = await supabase.auth.getUser()
          
          if (user) {
            // 检查用户角色
            const { data: roleData, error: roleError } = await supabase
              .from("user_roles")
              .select("role")
              .eq("user_id", user.id)
              .maybeSingle()

            console.log("[登录页] 初始会话检查:", { roleData, roleError, user_id: user.id })

            if (!roleError && roleData && (roleData.role === "super_admin" || roleData.role === "admin")) {
              console.log("[登录页] 已登录管理员，跳转到管理后台")
              // 防止重复跳转
              if (!isRedirectingRef.current) {
                isRedirectingRef.current = true
                window.location.replace("/dashboard")
              }
              return
            }
          }
        }
      } catch (err) {
        console.error("[登录页] 检查会话失败:", err)
      } finally {
        setIsChecking(false)
      }
    }

    // 延迟检查，避免与登录流程冲突
    const timer = setTimeout(() => {
      checkSession()
    }, 1000)

    return () => clearTimeout(timer)
  }, []) // 只在组件挂载时执行一次

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    
    // 防止重复提交
    if (isLoading || isRedirectingRef.current) {
      console.warn("[登录页] 登录正在进行中或正在跳转，忽略重复请求")
      return
    }

    setError(null)
    setIsLoading(true)

    try {
      if (!supabase) {
        throw new Error("Supabase 未初始化")
      }

      console.log("[登录页] 开始登录流程...")

      // 登录
      const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
        email: email.trim(),
        password: password,
      })

      if (authError) {
        console.error("[登录页] 登录失败:", authError)
        throw authError
      }

      if (!authData.user) {
        throw new Error("登录失败：未获取到用户信息")
      }

      console.log("[登录页] 登录成功，用户ID:", authData.user.id)

      // 检查用户角色
      const { data: roleData, error: roleError } = await supabase
        .from("user_roles")
        .select("role")
        .eq("user_id", authData.user.id)
        .maybeSingle()

      console.log("[登录页] 角色查询结果:", { roleData, roleError, user_id: authData.user.id })

      // 如果查询失败或没有角色记录
      if (roleError) {
        console.error("[登录页] 查询角色失败:", roleError)
        if (roleError.code === '42501' || roleError.code === 'PGRST301') {
          throw new Error("权限配置错误，请联系系统管理员")
        }
        throw new Error("查询用户角色失败，请重试")
      }

      if (!roleData) {
        console.warn("[登录页] 用户没有角色记录，需要管理员分配")
        throw new Error("您还没有被分配角色，请联系系统管理员")
      }

      console.log("[登录页] 用户角色:", roleData.role)

      if (roleData.role !== "super_admin" && roleData.role !== "admin") {
        console.warn("[登录页] 用户不是管理员，登出")
        await supabase.auth.signOut()
        throw new Error("您没有管理员权限，请联系系统管理员")
      }

      // 登录成功，跳转到管理后台
      console.log("[登录页] 登录成功，准备跳转到管理后台")
      
      // 防止重复跳转
      if (!isRedirectingRef.current) {
        isRedirectingRef.current = true
        // 立即跳转，不等待
        window.location.replace("/dashboard")
      }
      
    } catch (err: any) {
      console.error("[登录页] 登录失败:", err)
      setError(err.message || "登录失败，请检查邮箱和密码")
      setIsLoading(false) // 确保重置加载状态
      isRedirectingRef.current = false // 重置跳转标记
    }
    // 注意：如果成功跳转，不会执行到这里
  }

  if (isChecking) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900">
        <div className="text-center">
          <Loader2 className="h-8 w-8 animate-spin text-white mx-auto mb-4" />
          <p className="text-white/70">检查登录状态...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-900 via-blue-950 to-slate-900 p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <div className="flex items-center justify-center mb-4">
            <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl flex items-center justify-center">
              <Shield className="h-6 w-6 text-white" />
            </div>
          </div>
          <CardTitle className="text-2xl text-center">管理员登录</CardTitle>
          <CardDescription className="text-center">
            请输入您的管理员账号和密码
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleLogin} className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}

            <div className="space-y-2">
              <Label htmlFor="email">邮箱</Label>
              <Input
                id="email"
                type="email"
                placeholder="admin@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isLoading}
                autoComplete="email"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="password">密码</Label>
              <Input
                id="password"
                type="password"
                placeholder="请输入密码"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
                autoComplete="current-password"
              />
            </div>

            <Button
              type="submit"
              className="w-full"
              disabled={isLoading}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  登录中...
                </>
              ) : (
                "登录"
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  )
}
```

---

## 2. 路由保护中间件代码

**文件**: `proxy.ts`

```typescript
import { createServerClient } from "@supabase/ssr"
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

const FALLBACK_SUPABASE_URL = "https://gjlhcpfvjgqabqanvgmu.supabase.co"
const FALLBACK_SUPABASE_ANON_KEY = "sb_publishable_OQSB-t8qr1xO0WRcpVSIZA_O4RFkAHQ"

export async function proxy(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL || FALLBACK_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || FALLBACK_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          response = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            response.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // 检查认证状态
  const {
    data: { session },
  } = await supabase.auth.getSession()

  const { pathname } = request.nextUrl

  // 保护管理后台路由
  if (pathname.startsWith("/dashboard") || pathname.startsWith("/admin")) {
    if (!session) {
      // 未登录，重定向到登录页
      const url = request.nextUrl.clone()
      url.pathname = "/login"
      url.searchParams.set("redirect", pathname)
      return NextResponse.redirect(url)
    }

    // 已登录，检查是否是管理员
    // 注意：如果查询失败，允许通过，让前端页面自己检查权限
    try {
      const { data: roleData, error: roleError } = await supabase
        .from("user_roles")
        .select("role")
        .eq("user_id", session.user.id)
        .maybeSingle()

      if (roleError) {
        // RLS 查询失败时，允许通过，让前端页面自己处理权限检查
        console.warn("[中间件] 查询用户角色失败，允许通过:", roleError.message)
        return response
      }

      if (!roleData || (roleData.role !== "super_admin" && roleData.role !== "admin")) {
        // 不是管理员，重定向到登录页
        console.warn("[中间件] 用户不是管理员，重定向到登录页")
        const url = request.nextUrl.clone()
        url.pathname = "/login"
        url.searchParams.set("error", "unauthorized")
        return NextResponse.redirect(url)
      }

      // 是管理员，允许访问
      console.log("[中间件] 管理员用户，允许访问:", session.user.email)
    } catch (error) {
      console.error("[中间件] 检查用户角色异常:", error)
      // 异常时允许通过，让前端处理
      return response
    }
  }

  // 注意：完全禁用登录页的自动重定向，避免循环
  // 让前端页面自己处理已登录用户的跳转

  return response
}

export const config = {
  matcher: [
    "/dashboard/:path*",
    "/admin/:path*",
    "/login",
  ],
}
```

---

## 3. Supabase 客户端配置

**文件**: `lib/supabase.ts`

```typescript
import { createClient, SupabaseClient } from "@supabase/supabase-js"

// 设置后备值：如果 process.env 为空，直接使用字符串初始化
const FALLBACK_SUPABASE_URL = "https://gjlhcpfvjgqabqanvgmu.supabase.co"
const FALLBACK_SUPABASE_ANON_KEY = "sb_publishable_OQSB-t8qr1xO0WRcpVSIZA_O4RFkAHQ"

// 优先使用环境变量，如果为空则使用后备值
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || FALLBACK_SUPABASE_URL
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || FALLBACK_SUPABASE_ANON_KEY

// 检查配置是否有效
const isSupabaseConfigured = !!(
  supabaseUrl && 
  supabaseAnonKey && 
  supabaseUrl.trim() !== "" &&
  supabaseAnonKey.trim() !== ""
)

// 调试日志（仅在开发环境或服务器端输出）
if (typeof window === 'undefined') {
  console.log('[Supabase 配置] 使用环境变量 URL:', !!process.env.NEXT_PUBLIC_SUPABASE_URL)
  console.log('[Supabase 配置] 使用环境变量 Key:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY)
  console.log('[Supabase 配置] Supabase URL:', supabaseUrl.substring(0, 30) + '...')
  console.log('[Supabase 配置] Supabase Key 前10字符:', supabaseAnonKey.substring(0, 10) + '...')
  console.log('[Supabase 配置] 配置有效:', isSupabaseConfigured)
} else {
  // 客户端也输出部分信息（用于调试）
  console.log('[Supabase 配置] Supabase URL:', supabaseUrl.substring(0, 30) + '...')
  console.log('[Supabase 配置] Supabase Key 前10字符:', supabaseAnonKey.substring(0, 10) + '...')
}

// 创建客户端函数（确保在服务器端和客户端都能正确初始化）
function createSupabaseClient(): SupabaseClient | null {
  if (!isSupabaseConfigured) {
    if (typeof window === 'undefined') {
      // 服务器端：记录警告但不抛出错误
      console.warn('[Supabase] 服务器端：配置无效，使用后备值')
    }
    // 即使配置无效，也尝试使用后备值创建客户端
    try {
      return createClient(FALLBACK_SUPABASE_URL, FALLBACK_SUPABASE_ANON_KEY, {
        auth: {
          persistSession: false,
          autoRefreshToken: false,
          detectSessionInUrl: false,
        },
      })
    } catch (error) {
      console.error('[Supabase] 创建客户端失败:', error)
      return null
    }
  }

  try {
    return createClient(supabaseUrl, supabaseAnonKey, {
      // 确保在 SSR 环境中不会访问浏览器 API
      auth: {
        persistSession: typeof window !== 'undefined',
        autoRefreshToken: typeof window !== 'undefined',
        detectSessionInUrl: typeof window !== 'undefined',
      },
    })
  } catch (error) {
    console.error('[Supabase] 创建客户端失败:', error)
    // 如果创建失败，尝试使用后备值
    try {
      return createClient(FALLBACK_SUPABASE_URL, FALLBACK_SUPABASE_ANON_KEY, {
        auth: {
          persistSession: false,
          autoRefreshToken: false,
          detectSessionInUrl: false,
        },
      })
    } catch (fallbackError) {
      console.error('[Supabase] 使用后备值创建客户端也失败:', fallbackError)
      return null
    }
  }
}

// 导出客户端（在模块级别创建，确保单例）
export const supabase = createSupabaseClient()

// 导出配置状态（供其他模块检查）
export { isSupabaseConfigured }
```

---

## 4. 创建公司 API（需要登录验证）

**文件**: `app/api/admin/create-company/route.ts` (部分代码)

```typescript
import { NextResponse } from "next/server"
import { createClient } from "@supabase/supabase-js"
import { createServerClient } from "@supabase/ssr"
import { cookies } from "next/headers"

const FALLBACK_SUPABASE_URL = "https://gjlhcpfvjgqabqanvgmu.supabase.co"
const FALLBACK_SUPABASE_ANON_KEY = "sb_publishable_OQSB-t8qr1xO0WRcpVSIZA_O4RFkAHQ"
const FALLBACK_SERVICE_ROLE_KEY = "sb_secret_Nf3MT3QFxzXzr60Myh6VwA_K3-II_Nd"

export async function POST(request: Request) {
  try {
    // 第一步：验证用户登录状态和权限
    const cookieStore = await cookies()
    const supabaseClient = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL || FALLBACK_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || FALLBACK_SUPABASE_ANON_KEY,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll()
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) =>
                cookieStore.set(name, value, options)
              )
            } catch {
              // 忽略错误
            }
          },
        },
      }
    )

    // 获取当前登录用户
    const {
      data: { user },
      error: authError,
    } = await supabaseClient.auth.getUser()

    if (authError || !user) {
      return NextResponse.json(
        {
          success: false,
          error: "未授权",
          details: "请先登录管理员账号",
        },
        { status: 401 }
      )
    }

    // 检查用户是否是管理员
    const { data: roleData, error: roleError } = await supabaseClient
      .from("user_roles")
      .select("role")
      .eq("user_id", user.id)
      .single()

    if (roleError || !roleData) {
      return NextResponse.json(
        {
          success: false,
          error: "权限不足",
          details: "您没有管理员权限",
        },
        { status: 403 }
      )
    }

    if (roleData.role !== "super_admin" && roleData.role !== "admin") {
      return NextResponse.json(
        {
          success: false,
          error: "权限不足",
          details: "只有管理员可以创建公司",
        },
        { status: 403 }
      )
    }

    // ... 后续创建公司的逻辑
  } catch (err: any) {
    // ... 错误处理
  }
}
```

---

## 5. 数据库表结构和 RLS 策略

### user_roles 表结构

```sql
CREATE TABLE IF NOT EXISTS user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role VARCHAR(50) NOT NULL DEFAULT 'user' CHECK (role IN ('super_admin', 'admin', 'user', 'worker', 'supplier')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);
```

### RLS 策略（5条）

1. **Service role full access** - 服务角色完全访问
2. **Users can view their own role** - 用户只能查看自己的角色
3. **Users can insert their own role** - 用户只能插入自己的角色记录
4. **Users can update their own role** - 用户只能更新自己的角色记录
5. **Admins can view all roles** - 管理员可以查看所有角色

---

## 问题分析

### 可能的问题原因

1. **useEffect 循环触发**
   - 当前代码已使用 `useRef` 防止重复检查
   - `useEffect` 依赖项为空数组 `[]`，应该只执行一次

2. **中间件循环重定向**
   - 中间件在登录页检查已登录用户时可能触发重定向
   - 当前代码已禁用登录页的自动重定向

3. **会话未正确保存**
   - 登录成功后，会话可能未正确保存到 cookie
   - 导致跳转到 `/dashboard` 时被中间件拦截

4. **RLS 策略查询失败**
   - 中间件查询 `user_roles` 时可能因为 RLS 策略失败
   - 当前代码在查询失败时允许通过，让前端处理

### 当前已实施的保护措施

1. ✅ 使用 `useRef` 防止重复检查
2. ✅ 使用 `isRedirectingRef` 防止重复跳转
3. ✅ 禁用中间件在登录页的自动重定向
4. ✅ 使用 `window.location.replace()` 强制跳转
5. ✅ 添加防重复提交检查

---

## 建议的调试步骤

1. **检查浏览器控制台日志**
   - 查看 `[登录页]` 和 `[中间件]` 的日志
   - 确认登录流程是否正常执行

2. **检查网络请求**
   - 查看 `/user_roles` 请求的状态码和响应
   - 确认 RLS 策略是否正常工作

3. **检查 Cookie**
   - 确认 Supabase 的认证 cookie 是否正确设置
   - 确认 cookie 的域名和路径是否正确

4. **测试直接访问**
   - 尝试直接访问 `http://localhost:3000/dashboard`
   - 如果已登录，应该能直接访问

---

## 相关 SQL 脚本文件

### 1. 创建 user_roles 表

**文件**: `第一步_创建user_roles表.sql`

```sql
-- 创建用户角色表
CREATE TABLE IF NOT EXISTS user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role VARCHAR(50) NOT NULL DEFAULT 'user' CHECK (role IN ('super_admin', 'admin', 'user', 'worker', 'supplier')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_role ON user_roles(role);

-- 启用 RLS
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;
```

### 2. 修复 user_roles 表 RLS 策略

**文件**: `修复user_roles表RLS策略.sql`

```sql
-- 删除所有现有策略
DROP POLICY IF EXISTS "Service role full access to user_roles" ON user_roles;
DROP POLICY IF EXISTS "Users can view their own role" ON user_roles;
DROP POLICY IF EXISTS "Users can insert their own role" ON user_roles;
DROP POLICY IF EXISTS "Users can update their own role" ON user_roles;
DROP POLICY IF EXISTS "Admins can view all roles" ON user_roles;

-- 策略1：服务角色完全访问
CREATE POLICY "Service role full access to user_roles"
  ON user_roles FOR ALL
  TO service_role
  USING (true) WITH CHECK (true);

-- 策略2：用户只能查看自己的角色
CREATE POLICY "Users can view their own role"
  ON user_roles FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- 策略3：用户只能插入自己的角色记录
CREATE POLICY "Users can insert their own role"
  ON user_roles FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- 策略4：用户只能更新自己的角色记录
CREATE POLICY "Users can update their own role"
  ON user_roles FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- 策略5：管理员可以查看所有角色
CREATE POLICY "Admins can view all roles"
  ON user_roles FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid()
      AND role IN ('super_admin', 'admin')
    )
  );
```

### 3. 创建超级管理员账号

**文件**: `创建超级管理员账号.sql`

```sql
-- 方法1：通过 Supabase Dashboard 手动创建用户
-- 1. 进入 Supabase Dashboard
-- 2. 点击 "Authentication" -> "Users"
-- 3. 点击 "Add user" -> "Create new user"
-- 4. 填写邮箱和密码，勾选 "Auto Confirm User"

-- 方法2：为已存在的用户分配超级管理员角色
-- 假设用户邮箱是 admin@test.com，需要先获取该用户的 UUID
-- 然后执行：

INSERT INTO user_roles (user_id, role)
VALUES ('用户的UUID', 'super_admin')
ON CONFLICT (user_id) DO UPDATE SET role = 'super_admin';

-- 验证查询
SELECT u.email, ur.role, u.created_at
FROM auth.users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE ur.role IN ('super_admin', 'admin')
ORDER BY u.created_at;
```

---

## 环境变量配置

需要在 `.env.local` 中配置：

```
NEXT_PUBLIC_SUPABASE_URL=https://gjlhcpfvjgqabqanvgmu.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=sb_publishable_OQSB-t8qr1xO0WRcpVSIZA_O4RFkAHQ
SUPABASE_SERVICE_ROLE_KEY=sb_secret_Nf3MT3QFxzXzr60Myh6VwA_K3-II_Nd
```

---

## 依赖包

- `@supabase/supabase-js`: ^2.89.0
- `@supabase/ssr`: ^0.8.0
- `next`: 16.0.10
- `react`: 19.2.0

---

## 当前状态

- ✅ 登录页面代码已优化，添加了防循环保护
- ✅ 中间件已禁用登录页的自动重定向
- ✅ RLS 策略已创建（5条策略）
- ✅ 管理员角色已分配（admin@test.com 为 super_admin）
- ❌ 仍然存在循环登录问题

---

## 需要进一步检查的问题

1. Supabase 会话 cookie 是否正确设置和传递
2. 中间件中的 `getSession()` 是否能正确读取会话
3. 是否存在其他代码在登录后自动触发重定向
4. 浏览器缓存或 Service Worker 是否干扰了登录流程

